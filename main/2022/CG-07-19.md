![WebAssembly logo](/images/WebAssembly.png)

## Agenda for the July 19th video call of WebAssembly's Community Group

- **Where**: zoom.us
- **When**: July 19th, 4pm-5pm UTC (July 19th, 9am-10am Pacific Time)
- **Location**: *link on calendar invite*

### Registration

None required if you've attended before. Send an email to the acting [WebAssembly CG chair](mailto:webassembly-cg-chair@chromium.org)
to sign up if it's your first time. The meeting is open to CG members only.

## Logistics

The meeting will be on a zoom.us video conference.
Installation is required, see the calendar invite.

## Agenda items

1. Opening, welcome and roll call
    1. Opening of the meeting
    1. Introduction of attendees
1. Find volunteers for note taking (acting chair to volunteer)
1. Adoption of the agenda
1. Proposals and discussions
    1. Update on [testing Custom Sections and Annotations](https://github.com/WebAssembly/design/issues/1445) (Yuri Iozzelli) [15 min]
3. Closure

## Agenda items for future meetings

*None*

### Schedule constraints

*None*

## Meeting Notes

### Attendees

- Thomas Lively
- Yuri Iozzelli
- Francis McCabe
- Conrad Watt
- Jay Phelps
- Yurii Rashkovskii
- Paolo Severini
- Jeff Charles
- Deepti Gandluri
- Alex Crichton
- Peter Huene
- Rich Winterton
- Bailey Hayes
- Brendan Dahl
- Ilya Rezvov
- Sebastien Deleuze
- Nick Fitzgerald
- Manos Koukoutos
- Andrew Brown
- Kevin Moore
- Heejin Ahn
- Mingqiu Sun
- Andreas Rossberg
- Zalim Bashorov
- Sergey Rubanov
- Nabeel Al-Shamma
- Krisztian Gacsal
- Slava Kuzmich
- Johnny Birch
- Petr Penzin
- Sam Clegg
- Steven Prine
- Luke Wagner



### Update on [testing Custom Sections and Annotations](https://github.com/WebAssembly/design/issues/1445) (Yuri Iozzelli) [15 min]

YI presenting [slides] (TODO)

RW: Is there work going on with the tools to add annotations? Like with a pragma in compilers?

YI: For C++ there is support for branch hinting in the Cheerp compiler, but not in LLVM upstream. There’s work to be done.

AR: There are some things we still don’t know how to handle, for example the name annotation idea. Names would go on parameters, functions, or locals. The problem there is that the parameters are syntactic sugar that don’t appear in the core AST, so it’s unclear where the annotations would go in the binary format.

YI: Omitted it, because I have some ideas on how to do it, for parameters, we can add elements to the AST nodes, nothing wrong with it, I haven’t tried to do it, but it should be solvable this way, but we would prefer not to introduce new AST nodes.

AR: You would need some sort of virtual extension to source positions to handle it. It gets messy.

FM: You could add that in the custom section itself, if there’s missing info in the AST..

AR: This is about round tripping the existing thing, we can always round trip by add the custom thing that just dumps the custom section as is.

YI: You cannot do that with branch hinting, but it would work for e.g. the name section.

AR: Why can’t we do it for branch hinting? Because of positions?

YI: The issue is that we don’t have a great way of referencing instructions. Byte offsets are not stable due to LEBs (the reference interpreter always uses 5 bytes for integers, for example).

AR: There is a way you could deal with that, which is the inverse of trying to find the locations.. Trying to match the annotations that are parsed, you could do the inverse by parsing the binary and using that to generate the custom section itself.. It’s nasty, but doable

YI: Here we were talking about outputting text…

AR: This would still work, produce wasm binary with the encoder, you know what offsets will be produced, and you can generate the custom sections with that

YI: But it’s not unique. Only works if we’re only using the reference interpreter

AR: But it is deterministic… Oh, I see. If you want to transfer it in text format…

YI: The other tool could assume you encode with minimum size, the other way is always encoding the maximum size, unfortunately we’re using byte offsets for other things too

TL: Is the problem that you put byte offsets into the text format, if you go back to the binary then the offsets no longer math on translation?

YI: Name section is good, they have a stable representation, the thing that are missing are instructions - instructions only need byte offsets

CW: Could all the things we want to index be represented with offsets in the text format?

YI: That’s the way I’m working around this, instead of adding a custom annotation, we just put the annotation next to it so it’s independent of the encoding

TL: For the add custom thing, we could add a symbolic thing we could put in there that uses instruction indices, @ instruction 5 or something similar, when you translate to the binary, you can translate to the offset, there is a relocation, but it could work

YI: Custom annotations are an escape patch for annotations you don’t know much about, if you don’t know what it is, you need a format that can communicate this information

CW: There could be a convention in the text format that we allow instruction offsets. The translation could fail.

AR: If you’re dealing with a custom section that you don’t understand, you don’t know it’s supposed to be an instruction

CW: We seem to be going the way of having a standardized way of translating byte offsets

YI: If we stick to a standard it’s not as much of a problem. Works for branch hinting.

AR: @ custom is just broken in the presence of byte offsets.

TL: Don’t think it’s possible for this to work when the size of integers is unstable. We should get it to work when integer sizes are preserved or other simpler cases.

AR: I’m thinking that @ custom is a bad idea. I can think of other cases where it wouldn’t work. Section indices might change or be interpreted differently, etc. You can imagine many ways the custom section might depend on choices in the binary encoding. In general this seems unsolvable, so maybe we shouldn’t try to pretend it would work.

PP: We decided on byte offsets earlier after discussing different styles of encoding. Did we rule out putting annotations between instructions?

YI: No, we support that and that’s how branch hinting works. You put the annotation right before the instruction that you are instrumenting. One reason we ruled out instruction indices was that it doesn’t play well with feature detection, which can remove instructions. Other reasons are that DWARF and all other tools already use byte offsets.

PP: So can’t we use that in annotations?

YI: Some terminology confusion here. We’re just proposing removing “@custom”, not the general annotation mechanism. For branch hinting, the binary has a custom section that includes byte offsets. When you convert this into text, it uses annotations on the specific branching instructions. For future things that want to reference instructions, they can do the same thing and define both a binary and text format.

PP: Any proposal that makes instruction references part of the code has to define how they are encoded in text. I think this makes sense. Another question is what if the metadata is put in the instruction stream directly? Then you wouldn’t need to put it in a custom section in the binary and we wouldn’t have this problem.

AR: That would be much more specialized. Still unclear how you would annotate parameters, etc. The idea behind using custom sections is that they are fully general. I think that basic idea is still right.

PP: Do we need a special case for instruction indexing case? Both branch hints and tracing use this.

TL: I think the previous suggestion to drop the “@custom” mechanism solves the problem and is reasonable.

PP: Would having metadata in the instruction stream be easier for tools to emit? They wouldn’t need to calculate byte offsets.

YI: It would make some things simpler but not everything. I don’t think making it easier for the producer is worth much. What we have now is simple for engines.

AR: An intermediate solution would be to have a more general custom section that is something like code annotations that standardizes the association of metadata with code. The metadata can be custom, but the framework can be shared.

YI: That’s the idea of the code metadata. Proposals should use this shared framework unless there is such a need.

CW: This is blessing a special kind of custom section.

YI: Yes. It’s already documented in tool conventions. I thought it didn’t make sense to add as part of the spec since the only users are branch hinting and instrumentation tracing.

AR: It might make sense to add to the spec. Not sure.
